# -*- coding: utf-8 -*-
"""bot model.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/178ljnx5btXQUZ3HILXJpwakmk7ttKbFO
"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
import warnings
warnings.filterwarnings('ignore')

import pandas as pd

# Load the CSV data
def load_data(file_path):
    try:
        return pd.read_csv('/content/NGM156.csv')
    except Exception as e:
        print(f"Error loading data: {e}")
        return None

# Function to calculate daily duration, end-of-day KWHIMP1, and "off" hours
def calculate_daily_metrics(data, start_date, end_date):
    # Convert 'timestamp' to datetime for proper filtering
    data['timestamp'] = pd.to_datetime(data['timestamp'], errors='coerce')

    # Filter the data for the given date range
    data['date'] = data['timestamp'].dt.date
    filtered_data = data[(data['date'] >= pd.to_datetime(start_date).date()) &
                         (data['date'] <= pd.to_datetime(end_date).date())]

    if filtered_data.empty:
        print("No data found in the specified date range.")
        return pd.DataFrame()

    # Ensure DI2 is treated as an integer
    filtered_data['DI2'] = filtered_data['DI2'].astype(int)

    daily_metrics = []

    # Group data by date
    grouped = filtered_data.groupby('date')

    for date, group in grouped:
        # Calculate the total "on" duration in minutes
        group['DI2_shifted'] = group['DI2'].shift(1, fill_value=0)
        on_durations = []
        current_start = None

        for _, row in group.iterrows():
            if row['DI2'] == 1 and row['DI2_shifted'] == 0:
                current_start = row['timestamp']
            elif row['DI2'] == 0 and row['DI2_shifted'] == 1 and current_start:
                current_end = row['timestamp']
                duration = abs((current_end - current_start).total_seconds()) / 60  # Duration in minutes
                on_durations.append(duration)
                current_start = None

        # Handle case where the day ends with the well still "on"
        if current_start:
            current_end = group.iloc[-1]['timestamp']
            duration = abs((current_end - current_start).total_seconds()) / 60
            on_durations.append(duration)

        total_duration_minutes = sum(on_durations)
        total_duration_hours = total_duration_minutes / 60  # Convert to hours

        # Calculate "off" hours
        off_hours = 24 - total_duration_hours

        # Get the end-of-day KWHIMP1 value
        end_of_day_row = group.loc[group['timestamp'].idxmax()]
        end_of_day_kwhimp1 = end_of_day_row['KWHIMP1']

        # Append results
        daily_metrics.append({
            'date': date,
            'total_duration_minutes': total_duration_minutes,
            'end_of_day_kwhimp1': end_of_day_kwhimp1,
            'off_hours': off_hours
        })

    return pd.DataFrame(daily_metrics)

# Main function to execute
if __name__ == "__main__":
    file_path = input("Enter the path to your CSV file: ")
    data = load_data(file_path)

    if data is not None:
        start_date = input("Enter the start date (YYYY-MM-DD): ")
        end_date = input("Enter the end date (YYYY-MM-DD): ")

        # Calculate the daily metrics
        daily_metrics_df = calculate_daily_metrics(data, start_date, end_date)

        if not daily_metrics_df.empty:
            print("Daily Metrics:")
            print(daily_metrics_df)
        else:
            print("No relevant data found for the specified range.")

